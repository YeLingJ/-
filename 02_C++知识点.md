

# C++知识点

## 一、C++基础问题

#### 1.C++和C的区别？

区别：最大的区别在于它们解决问题的思想方法不一样。

- C语言是<font color=#ff0000>面向过程</font>的语言，它的重点在于算法和数据结构，C程序的设计首先考虑的是如何通过一个过程，对输入进行运算得到输出。

- C++语言是<font color=#ff0000>面向对象</font>的语言，在设计中首先考虑的是如何构造一个对象模型，让这个对象模型弄个配合对应的问题，这样就可以通过获取对象的状态信息来得到输出或实现过程控制。

联系：C是C++的一个子集，C实现了C++中过程化控制和其他相关功能。

#### 2. 面向对象四大特性？

- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象，抽象只关注对象的哪些属性和行为，并不关注这些行为的细节是什么。（数据抽象：一类事物的特征，过程抽象：一类事物的行为）
- **封装**：将一类或一种对象的属性和行为组合在一起，隐藏属性和行为实现过程，对外提供公共的访问方式，以防止数据得到随意访问和修改。
- **继承**：通过扩展一个已有类，并继承该类的属性和行为，来创建一个新的类。
- **多态**：对于不同对象接收相同消息时产生不同的动作。程序运行时的多态通过继承和虚函数来体现。

#### 3. 指针和数组的区别？
- 指针是一个变量，用于存储一个地址
- 数组是存储多个相同类型的变量的一个集合
- 赋值：同类型的指针变量可以相互赋值，数组只能一个一个元素的赋值或拷贝
- 数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据下标来进行访问，多维数组在内存中是按照一维数组存储的，只是逻辑上是多维的。 **数组的存储空间，不是静态区就是在栈上**
- 指针很灵活，可以指向任意类型的数据，指针的类型说明了它所指向的地址空间的内存。



#### 4. 指针和引用的区别？

##### 4.1 定义和性质上的区别

- 指针：指针是一个变量，存储一个地址，指向内存的一个存储单元

- 引用：引用是一个变量的别名，和原变量是同一个东西

- 可以有const指针，但没有const引用；

- 指针可以有多级，但引用只有一级；

- 指针可以为空，但引用的之不能为空，引用在定义的时候必须初始化；

- 指针的之在初始化后可以改变，可以指向其他存储单元，而引用在初始化后不会再改变了；

- sizeof引用得到的是指向变量的大小，而sizeof指针得到的是指针本身的大小；

- 指针和引用的自增运算意义不一样

##### 4.2 作为函数参数传递时的区别

- 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用指针传递函数的参数，当发生函数调用时，会创建一个临时的局部指针变量的形参，指向实参的地址，本质上两者都可以改变实参的值。



#### 5. new/delete和malloc/free的区别与联系？

- new/delete是C++运算符，malloc/free是C/C++语言的标准库函数。其实new/delete内部的实现也是调用了malloc/free，它们都用于在堆上动态内存的操作（申请动态内存和释放内存）；
- 用malloc函数需要指定内存分配的字节数并且不能初始化对象，new会自动调用对象的构造函数。delete会调用对象的析构函数，而free函数不会调用。
- new是强制类型的，不需要考虑类型，而malloc不是，它返回的指针是void*类型，必须强制转化为需要的类型。



#### 6. static的作用？（和不同对象联用时的作用）

- 修饰全局变量时，表明一个全局变量只对定义在同一个文件中的函数可见。
- 修饰局部变量时，表明该变量不会因为函数终止而丢失；
- 修饰函数时，表明该函数只在同一个文件中调用；
- 修饰类的数据成员，表明对该类的所有对象这个数据成员只有一个实例，即该实例归所有对象共有。
- 修饰类成员方法时，该方法只能访问她的参数、类的静态数据成员和全局变量。



#### 7. Const 的作用？（和不同对象联用时的作用）

- 修饰变量，说明该变量不可以被改变

- 修饰指针，分为指向常量的指针和指针常量

  1、指针常量--指针类型的常量（int * const p）

  本质上是一个常量，指针用来说明该常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，不可以改变，始终指向同一个地址，在定义时同时必须初始化。

  `int  a = 10;`

  `int * const p = &a;`

  `*p = 20; // p指向的地址是一定的，但是其内容可以修改。`

  2、常量指针--指向常量的指针（const int * p,  int const *p）

  常量指针本质上是一个指针，指针表示指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可以改变的，指针看起来好像指向了一个常量。

  `int a = 10, b = 20;`

  `const int *p = &a;`

  `p = &b;  // 指针可以指向其他的地址，但是内容不可以改变`

- 常量引用，经常用于修饰形参，即避免了拷贝，又避免了函数对值得修改；

- 修饰成员函数，说明该成员函数内不能修改成员变量

#### 8. class与struct的区别？

- C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含数据类型的数据结构了，它已经获得了很多功能：

  - struct可以包含成员函数；

  - struct可以继承；

  - struc可以实现多态。
- 若不指明，struct成员的默认属性是public，class成员的默认属性是private;
- 若不指明，struct成员的默认继承权限是public，class成员的默认继承权限是private。



#### 9. C++中的几种类型转换，有什么区别？

- static_cast：最常用的类型转换，在正常情况下的类型转换，如把int转换为float：

```C++
int i;
float f;
f = (float)i; 或者 f = static_cast<float>(i);
```

- const_cast：用于取出const属性，把const类型的指针变成非const的指针，如：

```C++
const int *fun(int x, int y){}
int *ptr = const_cast<int *>(fun(2,3));
```

- 该操作符用于运行时检查该转换是否符合类型安全，但只有在多态类型时合法，即该类至少具有一个虚拟方法。dynamic_cast与static_cast具有相同的基本语法。dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查功能，比static更安全。

```C++
class c
{
//此类没有虚拟函数
};

class T
{

};

int main()
{
	dynamic_cast<T*> (new c);//错误
}

//修改
class C
{
public:
virtual void m(){};
};
```

- reinterpret_cast

interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但不改变其值。如：

```C++
int i;
char *ptr = "hello freind!";
i = reinterpret_cast<int>(ptr);//只是对指针变量ptr说的值进行重新解释
```

这种方式很少用。

#### 10. C++中的智能指针，有什么区别？
智能指针主要用于管理在堆上分配的内存，本质上是个类，它将普通的指针封装成一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。

- shared_ptr

  shared_ptr智能指针的解决思路：最后一个引用它的对象被释放时，释放这段内存。

  实现方法：对被管理的资源进行计数。当一个sharedptr对象要共享这个资源的时候，该资源的引用计数加1，当该对象生命周期结束了，再把该引用计数减1。这样，当最后一个引用它的对象被释放的时候，资源的引用计数减少到0，此时释放该资源。

- weak_ptr

  是一种不控制所指向对象生命周期的智能指针，它指向一个shared_ptr管理的对象。

  weak_ptr绑定到shared_ptr时，不会改变对象的引用计数。
   当shared_ptr被销毁时，指向的对象也被销毁。不论weak_ptr是否指向了它

  用途：在不影响 智能指针所指向对象的生存周期的同时，判断对象是否存在(使用 `lock`方法)，从而避免 访问一个不存在的对象 的情况。

- unique_ptr

  一个unique_ptr `拥有` 它所指向的对象。

  1. 与sharedptr不同，某个时刻只能有一个uniqueptr指向一个给定对象。
  2. 当uniqueptr被销毁时，它所指向的对象也被销毁。

  uniqueptr不支持普通的拷贝和赋值操作，但是可以通过release or reset来转移所有权。

  用途：管理一些对象：不需要被共享，但也希望能够在超出作用域时，自动释放资源。

  ```C++
  void test_uniq_ptr() {
      std::unique_ptr<int> p1(new int(3));
  //    std::unique_ptr<int> b;
  //    b = a; //不支持赋值操作
  //    std::unique_ptr<int> b = a;  //不支持拷贝构造
      
      //把p1指向的对象转移给p2
      std::unique_ptr<int> p2(p1.release());// release操作会自动给p1赋空
      cout << *p2 << endl;
      if (p1 == nullptr) {
          cout << "p1 is nullptr" << endl;
      }
      
      std::unique_ptr<int> p3(new int(4));
      
      //reset 会释放本对象
      //release 会转移所有权
      p2.reset(p3.release()); //p2释放原来的对象，同时指向p3所指向的对象，p3赋空
      if (p3 == nullptr) {
          cout << "p3 is nullptr" << endl;
      }
         
      //释放对象，同时赋空
      p2.reset();
      if (p2 == nullptr) {
          cout << "p2 is nullptr" << endl;
      }
      
      //release操作会放弃当前指针的控制权，但是并不会销毁它。
      //因此通常调用release操作
      // 是为了 赋值  给另一个智能指针，
      // 而不是 为了销毁对象
      std::unique_ptr<int> p(new int(3));
      auto px = p.release(); //让出指针所有权，但是并没有销毁
      delete px; //这里需要手动delete px
  }
  ```

  

#### 11. 变量的声明和定义有什么区别

定义：为变量分配地址和存储空间。

声明：不分配地址。

一个变量可以在多个地方声明，但只在一个地方定义。

加入extern修饰的是变量的声明，说明此变量将在文件以外或文件后面部分定义。

#### 12. 写出bool、int、float、指针变量的零值比较的if语句

```c++
//bool型数据
if (flag) {
    A;
} else {
    B;
}

//int数据
if (0 != flag) {
    A;
} else {
    B;
}

//指针型数据
if (NULL == flag) {
    A;
} else {
    B;
}

//float型数据
if ((flag >= NORM) && (flag <= NORM))
 
```

注意：int、指针型变量和“零值”比较的时候，把零值放在左边，这样当把“==”误写成“=”时，编译器可以报错，否则这种逻辑错误不容易发现，并可能导致严重的后果。

#### 13. sizeof和strlen的区别

- sizeof是一个操作符，strlen是库函数
- sizeof的参数可以是数据类型，也可以是变量，strlen只能以结尾为'\0'的字符串作为参数；
- 编译器在编译时就计算出sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的数据类型所占的内存空间的大小，而strlen计算的是字符串实际的长度。
- 数组做sizeof的参数不退化，传递给strlen就退化为指针了。

#### 14. C语言的关键词static和C++的关键字static有什么区别

C语言中static用来修饰局部静态变量和外部静态变量、函数。

C++中除了C的功能，还用来定义类的成员变量和函数，即静态成员和静态成员方法。

注意：编程时static的记忆性和全局性的特点可以让不同时期调用的函数进行通信、传递信息，而C++的静态成员则可以在多个对象实例间进行通信、传递信息。

#### 15. C中的malloc和C++中的new有什么区别？

- new、delete是操作符，可以重载，只能在C++中使用
- malloc、free是函数，C、C++中都能使用；
- new可以调用对象的构造函数，对应的delete调用相应的析构函数；
- malloc仅仅分配内存，free仅仅回收内存；
- new、delete返回的是某种数据类型指针，malloc、free返回的是void指针

注意：malloc申请的内存空间要使用free释放，而new申请的内存空间要使用delete释放。

#### 16. 写一个标准宏MIN

```c
#define MIN(a,b) ((a)<=(b)?(a):(b))
```

注意：在调用时一定要注意这个宏定义的副作用，如下：

```c
MIN(++*p,x)
((++*p)<=(x)?(++*p):(x))//p指针自加了两次，违背的MIN的本意
```

#### 17. 一个指针可以是volatile吗？

volatile是一个特征修饰符，使用volatile修饰的编译不会被编译器更改。

指针可以被volatile修饰

指针和普通变量一样，有时也有变化的不可控性。常见例子：子中断服务子程序修改一个指向一个buffer指针时，必须用volatile来修饰这个指针。

说明：指针时一个普通变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是这个整型数据指向的是一段内存地址。

#### 18. a和&a有什么区别

请写出以下代码的打印结果：

```C
#include<stdio.h> 
void main( void ) 
{ 
 	int a[5]={1,2,3,4,5}; 
 	int *ptr=(int *)(&a+1); 
 	printf("%d,%d",*(a+1),*(ptr-1));  	
 	return; 
} 
```

结果：2,5

注意：数值名a可以作为数组的首地址，而&a是数组的指针；

#### 19. 简述C、C++程序编译的内存分配情况

- 从静态存储区域分配：

  内存在程序编译时就已经分配好，这块内存在程序中的整个运行期间都存在。速度快、不容易出错，因为有系统会善后，例如全局变量、static变量等；

- 从栈上分配：

  在执行函数时，函数内部局部变量的存储单元都是在栈上创建，函数执行结束时，这些存储单元自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但内存分配容量有限。

- 从堆上分配：

  即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时使用free或delete释放内存。动态内存的生存周期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，且频繁地分配和释放不同大小的对空间将产生堆内碎块。

  **一个C/C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。**

#### 20. 简述strcpy、sprintf与memcpy的区别

- 操作对象不同
  - strcpy的两个操作对象均为字符串；
  - sprintf的操作源对象可以是多种数据类型，且目的操作对象是字符串；
  - memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
- 执行效率不同
  - memcpy > strcpy > sprintf
- 实现功能不同
  - strcpy主要实现字符串变量间的拷贝
  - sprintf主要实现其他数据类型格式到字符串的转化
  - memcpy主要实现内存块间的拷贝

#### 21. 设置地址为0x67a9的整型变量的值为0xaa66

```c
int *ptr;
ptr = (int *)0x67a9;
*ptr= 0xaa66
```

#### 22. C++的空类有哪些成员函数

- 缺省构造函数
- 缺省拷贝构造函数
- 缺省析构函数
- 缺省赋值运算符
- 缺省取值运算符
- 缺省取值运算符const

#### 23. 谈谈你对拷贝构造函数和赋值运算符的认识

两者的不同：

- 拷贝构造函数生成新的类对象，而赋值运算符不能；
- 由于拷贝构造函数时直接构造一个新的类对象，所以在初始化这个对象之前不用检验对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配需要先把内存释放掉；

注意：当有类中有指针类型的成员变量时，一定要重新拷贝构造函数和运算符，不要使用默认的。

#### 24. 简述类成员函数的重写、重载和隐藏的区别

- 重载和重写的区别

  - 范围：重载是在同一个类中，重写是在两个类中；
  - 参数：重载的函数与被重载函数的参数列表一定不同，重写的函数与被重写函数的参数列表一定相同；
  - virtual的区别：重写的基类中被重写的函数必须有virtual修饰，而重载函数与被重载函数可以被virtual修饰，也可以没有

- 隐藏和重载、重写的不同

  - 与重载的范围不同：和重写一样，隐藏和被隐藏函数不在同一个类中；
  - 参数区别：隐藏函数与被隐藏的函数的参数列表可以相同，也可不同，但是函数名一定相同。当参数不同时，无论基类中的函数是否被virtual修饰，基类的函数都是被隐藏的，而不是被重写。

#### 25. 简述多态的实现原理

  编译器发现一个类中有虚函数，便会立即为此类生成虚函数表vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针vptr指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，将vptr指向对应的vtable，将此类与此类的vtable联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已变成指向具体的类的this指针，这样依靠this指针即可得到正确的vtable。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

#### 26. 链表和数组的区别

- 存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点都要保存相邻结点的指针。
- 数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。
- 数据插入与删除：链表可以快速的插入或删除结点，数组则可能需要大量数据移动；
- 越界问题：链表不存在越界问题，数组存在越界问题；

#### 27. 简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”；

注意：区别堆区和栈区：

- 堆区的存取是“顺序随意”，堆一般有程序员分配释放，若程序员不释放就要等程序结束时可能由OS回收。
- 栈区是后进先出，栈由编译器自动分配释放，存放函数的参数值、局部变量值等

队列、栈是数据结构，而堆区栈区是程序的不同内存存储区域。

#### 28. 谈谈你对编程规范的理解和认识

编程规范总结为：可行性、可读性、可移植性、健壮性、可测试性

#### 29. short i=0; i=i+1L; 这两句有错吗？

代码1错误，代码2正确。

在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。

#### 30. &&和&，||和|的区别

- &和|是操作数进行求值运算，&&和||只是判断逻辑关系；
- &&和||在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。

#### 31. extern有什么作用

extern标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时，其他模块中找寻其定义

#### 32. 流操作符重载为什么返回引用

在程序中，流操作符>> 和<< 经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用，其他的数据类型都无法做到这一点。

注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

#### 33. 简述指针常量与常量指针的区别

**指针常量**是定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。强调指针的不可变性

```C
int main()
{
	int a = 2;
	int b = 3;
	int *const c = &a;
	printf("albert:%p\n", c);
	c = &b;     //报错：expression must be a modifiable lvalue	
	printf("albert:%p\n",c);
}
---------------------------------------------------------------
int main()
{
	int a = 2;
	int b = 3;
	int *const c = &a;
	*c = 4;
	printf("albert:%d\n",*c);   //4
}

```

**常量指针**是定义了一个指针，这个指针指向一个只读对象，不能通过常量指针来改变这个对象的值。强调指针对其所指向对象的不可改变性。

```C
#改变指针b指向地址的内容
int main()
{
	int a = 2;
	int const *b = &a;
	*b = 3;  //报错：expression must be a modifiable lvalue	
	printf("albert:%d\n",a);
}
---------------------------------------------------------------
#改变指针b的指向
int main()
{
	int a = 2;
	int b = 3;
	int const *c = &a;
	printf("albert:%p\n", c);    
	c = &b;
	printf("albert:%p\n",c);
}
```

#### 34. 如何避免“野指针”

野指针产生原因及解决办法如下：

- 指针声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值也可以让他指向NULL；
- 指针被free或delete之后没有置为NULL。解决办法：指针指向的内存空间被释放之后指针应该指向NULL；
- 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间且让指针指向NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

#### 35. 常引用有什么作用

常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外改变。

说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。

#### 36. 谈谈你对面向对象的认识

面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的设计程序多是基本功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题，这样使得程序更加的简洁清晰。

## 二、C++进阶问题

#### 2.1析构函数能否作为虚函数？这样有什么好处？谈谈你理解的虚函数和多态？

- 析构函数可以作为虚函数。
- 在实现多态时，当基类操作派生类，在析构函数使用虚析构函数，可以防止只析构基类而不析构派生类的情况发生，避免造成内存泄漏。
- 多态是通过重写父类的成员函数来实现对象调用同一个方法时产生不同的行为。

#### 2.2 虚函数的实现原理

  虚函数的用法：可以让派生类重写基类的成员方法实现多态，虚函数实现多态的机制严格来说是动态多态，实在运行的时候实现的。

  虚函数的实现原理：C++通过虚函数表和虚函数表指针来实现虚函数机制。

  带有虚函数的类，编译器编译时会额外分配一个虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个虚函数的入口地址。对于一个派生类来说，他会继承基类的虚函数表，同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写得虚函数入口地址代替，那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。

  ![image-20200908224034042](C:\Users\Icey\AppData\Roaming\Typora\typora-user-images\image-20200908224034042.png)

  

#### 2.3 什么是内存对齐？为什么需要内存对齐？（给你一个结构体 可以计算出它的大小）

- 内存对齐的规则是按照结构体成员的声明顺序，依次安排内存，主要遵循两个规则：

​      1、每个成员的起始地址，相对于结构体的首地址的偏移量必须为该成员所占内存大小的整数倍。

​       2、结构体占内存的总长度是最大成员所占内存大小的整数倍。

- 为什么要内存对齐？

  可以使程序的执行效率提高，每个成员的起始地址，相对于结构体的首地址的偏移量，必须为该成员所占内存大小的整数倍，可以在访问成员变量的时候更迅速，所以如果数据没有内存对齐，CPU访问这些数据时，可能就需要执行更多次的读取操作才行。



#### 2.4  说说你会哪些排序算法？实现的思路？

- 冒泡排序：采用相邻两两比较的方式，较大的数值“下沉”，较小数值“上升”，经过一轮之后，最大的数据就放到的最后一个位置，以此类推。

- 插入排序：每次将一个待排序的元素和已排序的元素逐一比较，直到找到合适的位置按照大小插入。

- 选择排序：一开始就从原始序列中找到最小的元素，放在序列的起始位置作为已拍序列，然后在剩下的未排序的元素中找到最小的元素，放到已排序的序列末尾，以此类推，直到所有元素排列完毕。

- 希尔排序：将无序数组分割为若干子序列，子序列不是逐段分割的，而是相隔特定增量的子序列，对各个子序列进行插入排序，然后在选择一个更小的增量，再将数组分割为多个子序列进行排序，最后选择增量为1，即使用直接插入排序，使最终的数组成为有序

- 归并算法：归并排序算法首先将这个数据分成一半（左右两边），然后想办法把左边的数组给排序，右边的数组排序，之后在合并起来，当然了对左边的数组和右边的数组进行排序的时候，再分别将左边的数组和右边的数组分成一半，然后对每一个部分先排序，再归并。

- 堆排序算法：将无序序列构成一个堆，根据升序降序需求选择大顶堆或小顶堆；将对顶与末尾元素交换，将最大元素“沉”到数组末端；重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾的元素，反复进行调整加交换步骤，直到整个序列有序。

- 快速排序：

  - 从序列中挑出一个元素，作为基准；
  - 把所有比基准值小的元素放在基准的前面；
  - 所有比基准值大的元素放在基准的后面，称为分区操作；
  - 然后重复前面2，3步骤

  

#### 2.5 什么是字节序？写个算法你的电脑存储方式是大端存储还是小端存储？

- 字节序是指 多字节数据在计算机内存存储中存储或者网络传输时各字节的存储顺序。字节序有大小端之分。

  1、小端：将低序字节存储在起始地址

  2、大端：将高序字节存储在起始地址

  ![image-20200913173316851](C:\Users\Icey\AppData\Roaming\Typora\typora-user-images\image-20200913173316851.png)

  计算机内存中的数据通常是使用小端存储，而TCP/IP协议规定网络数据流应采用大端字节序，所以在网络通信中，接收和发送数据时往往涉及数据的大小端转换。

#### 2.6 什么是内存泄漏？如何检测你的程序有没有内存泄漏？你有没有用过什么检测工具？如何避免？

- 简单地说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表示方式是程序运行时间越来越长，占用内存越多，最后用尽全部内存，整个系统奔溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。
- 如何检测内存泄漏？
  - 良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄漏。当程序稳定之后，再检测内存泄漏的时候，就会增加排除困难和复杂度。使用了内存分配的函数，一旦使用完毕就要记得使用其相应的函数来释放掉。
  - 将分配的内存的指针以链表的形式自行管理，使用完之后从链表中删除，程序结束时可以检查该链表
  - boost中的smartpointer
  - 一些常用的工具插件，如ccmalloc、Dmalloc、Leack等等。

#### 2.7 什么是进程内存分区？const修饰的局部变量是在哪个分区？

每个进程所分配的内存由许多部分组成，通常我们称之为段。

1、代码段：只读，可共享。代码段通常是指用来存放程序执行代码的一段内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也运行代码段为可写，即允许修改程序。在代码段中，可能包含一些只读常数变量。例如字符串常量

#### 2.8 vector和list的区别以及应用场景？（什么时候他们的迭代器会失效）

- vector：
  - 优点：和数组类似，开辟一段连续的空间，并且支持随机访问，所以它的查找效率高，时间复杂度为O(1)；
  - 缺点：由于开辟一段连续的空间，所以插入删除时需要对数据进行移动，比较麻烦，时间复杂度为O(n)，另外，当空间不足时还需要进行扩容。
  
- list：
  - 优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度为O(1)；
  - 缺点：底层没有连续空间，只能通过指针来访问，所以查找数据需要遍历，其时间复杂度为O(n)；没有提供[]操作符重载。
  
- 应用场景：如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

- 失效问题：vector的迭代器失效发生在insert和erase中，list中的迭代器失效发生在erase中。

  https://blog.csdn.net/GangStudyIT/article/details/80876119

#### 2.9 set和map的区别以及底层实现？

- 底层实现：set和map都是C++关联容器，其底层实现都是红黑树（RB-tree）。由于set和map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set和map的操作行为，都只是转调RB-tree的操作行为。

- 区别：

  - map中的元素是key-value键值对，关键字其索引的作用，值则表示与索引相关联的数据；set与之相对的就是关键字的简单集合，set中每个元素只包含一个关键字。

  - set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。

    原因：set和map都是根据关键字排序来保证其有序性，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。

  - map支持下标操作，set不支持下标操作。

#### 2.10 什么是hash表？如何解决hash冲突？对字符串做hash有什么好的算法？



#### 2.11 Lambda是什么？

Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作

[函数对象参数] (操作符重载函数参数) mutable 或exception声明  -> 返回值类型{函数体}

1、[函数对象参数]

标识一个Lambda表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。

2、（操作符重载函数参数）

标识重载的()操作符的参数，没有参数时，参数可以通过按值和按引用两者方式传递。

3、mutable 或 exception声明

这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw（int）

4、返回值类型

标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方。

5、{函数体}

标识函数的实现，这部分不能省略，但是函数体可以为空。



#### 2.12 C++现在最新是什么版本？新版的有什么特效？

​	C++20

- 新增关键字：concept、requires...

- 新增标识符：import、module

  http://jimmysue.me/c-20-features/

#### 2.13 什么是二叉树、二叉排序树、二叉平衡树、红黑树（树相对其他数据结构有什么优点）

- 树状图是一种数据结构，它是由n(n>=1)个有限结点组成的一个具有层次的关系的集合。
- 二叉树：每个结点`最多`只能有一个子结点的叫二叉树。
  - 如果二叉树的所有叶子结点都在最后一层，并且结点总数=2^n-1，n为层数，则称之为满二叉树。
  - 如果二叉树的所有叶子结点都在最后一层或者倒数第二层，而且最后一层的叶子结点在左边连续，倒数第二层的叶子结点在右边连续，则称之为完全二叉树。

  

## 三、C++逻辑题

- 如何判断两个单向链表是否相交，如果相交，求出交点

  ​	如果两条单向链表相交的话，那么它们最后的一个节点一定是相同的，否则不相交。因此判断两个链表是否相交就分别遍历到两个链表的尾部，然后判断它们是否相同，如果相同则相交，否则不相交。

  ​	判断出两个链表相交后就是判断它们的交点，假设第一个链表长度为len1，第二个为len2，然后找出较长的，让较长的链表指针向后移动|len1-len2|，然后开始遍历两个链表，判断节点是否相同即可。

  ![image-20201025110500110](C:\Users\Icey\AppData\Roaming\Typora\typora-user-images\image-20201025110500110.png)

  ```c
  typedef struct node_t
  {
      int data;
      struct node_t *next;
  }node;
  
  node * find_node(node *head1, node *head2)
  {
      if (head1==NULL || head2== NULL) {
          return NULL;
      }
      node *p1,p2;
      int len1,len2,diff;
      p1 = head1;
      p2 = head2;
      
      while (NULL != p1->next) {
          p1 = p1->next;
          len1++;
      }
      
      while (NULL != p2->next) {
          p2 = p2->next;
          len2++;
      }
      
      if (p1 != p2) {
          return NULL;
      }
      
      diff = abs(len1 - len2);
      if (len1 > len2) {
          p1 = head1;
          p2 = head2;
      } else {
          p1 = head2;
          p2 = head1;
      }
      
      for (int i=0; i<diff; i++) {
          p1 = p1->next;
      }
      
      while (p1 != p2) {
          p1 = p1->next;
          p2 = p2->next;
      }
      
      return p1;
  }
  
  ```

  

- 判断链表是否有环？如果是求出环入口节点

  快慢指针法

  ```c
  typedef struct node_t
  {
      int data;
      struct node_t *next;
  }node;
  
  node * firstLoopStart(node *head)
  {
   	node *fast, slow;
      slow = fast = head;
      
      while (slow != NULL && fast->next != NULL) {
          slow = slow->next;
          fast = fast->next->next;
          if (slow == fast)
              break;
      }
      if (slow == NULL || fast->next == NULL)
          return NULL;//没有环
      node *p1 = head;
      node *p2 = slow;
      while (p1 != p2) {
          p1 = p1->next;
          p2 = p2->next;
      }
      return p1;
  }
  ```

- 两个栈实现一个队列

  栈的特性：先进后出

  队列的特性：先进先出

  思路：用pushStack栈作为push数据的栈，用popStack栈作为pop数据的栈

  - 只要是对队列进行push操作，就将数据push入pushStack中；
  - 要实现队列的pop操作，有两点原则，如果popStack为空的话，那么我们就将pushStack中所有元素都放到popStack中，然后取popStack栈顶元素就是队列的队头；如果popStack不为空的话就直接获取popStack的栈顶元素。
  - 对于top操作来说，和pop类似，只是最后一步不用pop了。

  https://blog.csdn.net/dangzhangjing97/article/details/81477192

- 求数组中出现次数超过一半的数字

  - 方法一：先排序，取中间的数，若这个数在数组中超过一步，则存在；否则不存在；
  - 方法二：用map键值来记录每个元素出现的次数，如果该元素出现的次数超过一半，返回个数。

- 跳台阶问题（一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法）

  ​    

- 如何找出单链表的倒数第k个节点

- 更多题目见剑指offer：https://www.nowcoder.com/ta/coding-interviews



## 四、C++手撕代码题

- 手撕-冒泡排序（思考怎么在原来的基础上改进算法）

  ```c++
  void bubbleSort(int a[], int len)
  {
      int temp;//中间变量
      bool flag;//优化标志，判断是否有交换
      for (int i=0; i<len; i++) {
          flag = false;
          for (int j=len-1; j>i; j--) {
              if (a[j] < a[j-1]) {
                  temp = a[j-1];
                  a[j-1] = a[j];
                  a[j] = temp;
                  flag = true;
              }
          }
          if(!flag)
              break;
      }
  }
  ```

- 手撕-快速排序（递归和非递归，思考使用递归可能存在什么问题）

  

- 其他排序可以不会手撕，但是要能说出实现的过程。博客地址：https://blog.csdn.net/qq_37266079/article/details/104958732

  `选择排序`：一开始就从原始的序列中找到最小的元素，放到序列的起始位置作为已排序序列，然后在剩下的未排序的元素中寻找最小的元素，放到已排序的序列末尾，以此类推，直到所有的元素排列完毕。z

  ```c++
  void selectionSort(int a[], int len)
  {
      int minIndex;
      int temp;
      for (int i=0; i<len; i++) {
          minIndex = i;
          for (int j=i+1; j<len; j++) {
              if (a[j] < a[minIdex]) {
                  minIndex = j;
              }
          }
          if (minIndex != i) {
              temp = a[i];
              a[i] = a[minIndex];
              a[minIndex] = temp;
          }
      }
  }
  ```

  `插入排序`：在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排列好的。如此反复循环，直到全部排好顺序。插入排序在实现上，采用in-place排序，因而在从后向前的扫描过程中，需要反复把已排序的元素逐步向后挪位，为最新元素提供插入空间。

  ```c++
  void insertSort(int a[], int len) 
  {
   	int temp;
      int i;
      int j;
      for (i=1; i<len; i++) {
          temp = a[i];
          j = i-1;
          while (j>=0 && a[j]>temp) {
              a[j+1] = a[j];
              j--;
          }
          a[j+1] = temp;
      }
  }
  ```

  `希尔排序` ：将无序数组分割成若干个子序列，子序列不知逐段分割的，而是相隔特定的增量的子序列，对各个子序列进行插入排序；然后再选择一个更小的增量，再将数组分割为多个子序列进行排序，最后选择增量为1，即使用直接插入排序，使最终数组成为有序的。

- 手撕-斐波那契数列的第n项（递归和非递归）

- 手撕-二叉搜索树 节点的删除

- strcpy和memcpy的区别，strcpy可能存在什么问题？手撕strcpy

- 手撕 反转链表（递归和非递归（递归较难））

- 手撕-封装单链表的类（初始化链表、增加、删除、修改）

- 手撕-二叉树遍历（广度、深度）

- 手撕-求一个数的平方根

- 手撕-最大公约数

- 手撕-二分查找

- 手撕-单例模式（懒汉、饿汉）

- 手撕-两个栈实现一个队列的功能

- 手撕-编码实现字符串转化为数字



